<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数据结构的绪论 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="数据结构第一章 算法一个例子首先我们要了解为什么需要算法与数据结构。一个问题：什么是数据结构？  数据对象在计算机中的组成方式 数据对象必定与一系列加在其上的操作相关联 完成这些操作所用的方法即为算法  为什么需要好的算法和数据结构方法一： 12345678910&#x2F;&#x2F;打印从1-N的所有整数void printfN(int N)&#123;    int i;    for(i&#x3D;1;i&lt;&#x3D;N;">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构的绪论">
<meta property="og:url" content="http://example.com/2025/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%AA%E8%AE%BA/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="数据结构第一章 算法一个例子首先我们要了解为什么需要算法与数据结构。一个问题：什么是数据结构？  数据对象在计算机中的组成方式 数据对象必定与一系列加在其上的操作相关联 完成这些操作所用的方法即为算法  为什么需要好的算法和数据结构方法一： 12345678910&#x2F;&#x2F;打印从1-N的所有整数void printfN(int N)&#123;    int i;    for(i&#x3D;1;i&lt;&#x3D;N;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-01-25T12:46:08.000Z">
<meta property="article:modified_time" content="2025-01-27T11:48:59.663Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构的绪论" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%AA%E8%AE%BA/" class="article-date">
  <time class="dt-published" datetime="2025-01-25T12:46:08.000Z" itemprop="datePublished">2025-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数据结构的绪论
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构第一章-算法"><a href="#数据结构第一章-算法" class="headerlink" title="数据结构第一章 算法"></a>数据结构第一章 算法</h1><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>首先我们要了解为什么需要算法与数据结构。<br><br>一个问题：什么是数据结构？<br></p>
<ul>
<li>数据对象在计算机中的组成方式</li>
<li>数据对象必定与一系列加在其上的操作相关联</li>
<li>完成这些操作所用的方法即为算法</li>
</ul>
<h2 id="为什么需要好的算法和数据结构"><a href="#为什么需要好的算法和数据结构" class="headerlink" title="为什么需要好的算法和数据结构"></a>为什么需要好的算法和数据结构</h2><p>方法一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//打印从1-N的所有整数</span><br><span class="line">void printfN(int N)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=1;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：采用递归的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void printN(int N)</span><br><span class="line">&#123;</span><br><span class="line">    if(N)</span><br><span class="line">    &#123;</span><br><span class="line">        printN(N-1);</span><br><span class="line">        printf(&quot;%d\n&quot;,N);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据量达到100000时，递归空间直接爆掉。</p>
<h2 id="给出一个测时间的函数"><a href="#给出一个测时间的函数" class="headerlink" title="给出一个测时间的函数"></a>给出一个测时间的函数</h2><p><strong>当测量一次的时间比较短系统显示不出来的时候，采用运行100次或者多次函数的时间，再进行平均即可</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;time.h&gt;</span><br><span class="line">clock_t start,stop;//clock_t是clock函数返回的数据类型</span><br><span class="line">double duration;//记录运行时间，单位为秒</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //预先的处理</span><br><span class="line">    start=clock();</span><br><span class="line">    MyFunction();//自己的函数</span><br><span class="line">    stop =clock();</span><br><span class="line">    duration=((double)(stop-start))/CLK_TCK;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="理解抽象数据类型的定义和优点"><a href="#理解抽象数据类型的定义和优点" class="headerlink" title="理解抽象数据类型的定义和优点"></a>理解抽象数据类型的定义和优点</h2><h1 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h1><h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p>与数据的存储无关，独立于计算机。<br>分为线性结构和非线性结构。–线性表为典型的线性结构，图和数是典型的非线性结构<br>线性结构：元素之间只存在一对一的关系<br>非线性结构：元素之间一对多或者多对多的关系</p>
<h2 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h2><p>数据结构在计算机中的表示，也成为物理结构，是用计算机语言实现的逻辑结构<br>一般有<strong>链式存储，顺序存储，索引存储，散列存储</strong><br>1.顺序存储：逻辑上相邻的元素在物理结构上也相邻，<strong>元素之间的关系由存储单元的邻接关系来体现</strong>，可以实现<em>随机存取</em>，但是只能采用相邻的一整块物理存储单元，容易有<em>外部碎片</em><br>2.链式存储：不要求逻辑上相邻的元素在物理结构上也是相邻的，可以借助<strong>指针</strong>来表示元素之间的逻辑关系，不会产生碎片，对存储单元的利用比较充分，但是保存指针会占用额外的空间，且只能顺序存取。<br>3.索引存储：在存储元素信息的同时，附加建立的索引表，索引每一项被称为索引项。优点：检索速度快，但是缺点是附加的索引表会占据一定的空间，增删数据会修改索引表，会花费额外的时间。<br>4.散列存储：有称为hash存储，根据关键字，直接计算出存储的地址，优点 是<strong>检索增加删除的操作都很快</strong>，缺点是<strong>会产生冲突</strong></p>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="线性表的定义和基本操作"><a href="#线性表的定义和基本操作" class="headerlink" title="线性表的定义和基本操作"></a>线性表的定义和基本操作</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>具有相同数据数据类型的n个<strong>数据元素</strong>的有限序列，n为表长，n为0时为空表。<br>&lt;数据元素由数据项组成<br>除了第一个元素每一个元素都有唯一一个前驱，除了最后一个元素，每一个都有一个后继。<br>线性表是一个抽象的逻辑结构，注意区分顺序表和链表（这是存储结构）。</p>
<h3 id="数组的存储分配"><a href="#数组的存储分配" class="headerlink" title="数组的存储分配"></a>数组的存储分配</h3><p>1.静态分配：数组的大小和空间已经确定，一旦空间占满，新数据就会溢出，程序崩溃。在 C 语言中，静态数组的内存分配在栈区，<br>  生命周期：静态数组的生命周期始于其定义时。如果在函数内部定义，生命周期与函数的调用相同；如果在全局范围定义，生命周期贯穿整个程序运行。<br>  静态数组的声明和初始化示例：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int staticArray[5]; // 静态数组声明</span><br><span class="line">int staticArray[] = &#123;1, 2, 3, 4, 5&#125;; // 静态数组声明并初始化</span><br></pre></td></tr></table></figure><br>  对于静态数组，可以使用 sizeof 运算符来获取数组长度，例如：<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int array[] = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">int length = sizeof(array) / sizeof(array[0]); </span><br></pre></td></tr></table></figure><br>2.动态分配：存储数组的空间在程序执行的过程中动态分配，如果数据空间满了，就开辟一块更大的存储空间，将原来的元素拷贝到新的空间中，不需要一次性的划分所有的空间。<br>   动态数组是在运行时通过动态内存分配函数（如 malloc 和 calloc,在c++中用new）手动分配内存的数组。<br>   内存分配：动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。<br>   <strong>分配一定要回收，动态数组的使用需要注意内存管理的问题，确保在不再需要使用数组时释放内存，避免内存泄漏和访问无效的内存位置。</strong><br>   动态数组的大小在运行时可以根据需要进行调整。可以使用 realloc 函数来重新分配内存，并改变数组的大小。<br>   在代码中，我们使用的是malloc和free函数，这两个函数一同维护一块内存池，当我们需要内存空间时，malloc函数就从系统内存为我们找到合适的空间并返回指针，<br>   当我们不需要此块内存时就可以用free函数释放将使用权交由系统。malloc函数的参数就是需要分配的字节数，malloc返回的类型是一个void * 的指针，<br>   一般要求你在转换时使用强制类型转换。free的参数要么是null，要么是之前从malloc的返回值。<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);</span><br><span class="line">L.data=new ElemType[InitSize];</span><br></pre></td></tr></table></figure></p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>   1.初始化和插入操作<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define Maxsize 10;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line"> int data[Maxsize];</span><br><span class="line"> int length;</span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line">//初始化</span><br><span class="line">void InitList(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line"> L.length=0;</span><br><span class="line">&#125;</span><br><span class="line">//插入操作</span><br><span class="line">bool ListInsert(SqList &amp;L,int i,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line"> if(i&gt;L.length+1||i&lt;1||L.length&gt;=Maxsize)</span><br><span class="line"> &#123;</span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br><span class="line"> for(int j=L.length;j&gt;=i;j--)</span><br><span class="line"> &#123;</span><br><span class="line">     L.data[j-1]=L.data[j];</span><br><span class="line"> &#125;</span><br><span class="line"> L.data[i-1]=e;</span><br><span class="line"> length++;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>   最好的复杂度：O（1），在最后插入元素，不用移动节点<strong>0</strong>个节点<br>   最还的复杂度：O（n），在第一个地方插入一，移动后面<strong>n</strong>个节点<br>   平均的时间复杂度：O（n）  移动节点的平均次数为（n）&#x2F;2</p>
<p>   2.删除操作<br>   删除L中的第i个元素，并返回该位置变量e,若i输入不合法，返回false<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool ListDelete(SqList &amp;L,ElemType &amp;e,int i)</span><br><span class="line">&#123;</span><br><span class="line"> if(i&lt;1||i&gt;L.length)</span><br><span class="line"> return false;</span><br><span class="line"> e=L</span><br><span class="line"> for(int j=i;j&lt;L.length;j++)</span><br><span class="line"> &#123;</span><br><span class="line">     L.data[j-1]=L.data[j];</span><br><span class="line"> &#125;</span><br><span class="line"> L.length--;</span><br><span class="line"> return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>   最好的复杂度：删除表尾元素，不用移动节点为<strong>0</strong>，时间复杂度为O（1）；<br>   最还的复杂度：删除表头元素，移动<strong>n-1</strong>个节点，时间复杂度为O（n）;<br>   移动节点的平均次数为（n-1）&#x2F;2</p>
<h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><p>   在顺序表L中查找第一个元素值等于e的元素，返回其位序<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int LocateElem(SqList L,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line"> int i;</span><br><span class="line"> for(i=0;i&lt;L.length;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     if(L.data[i]==e)</span><br><span class="line">     return i+1;</span><br><span class="line"> &#125;</span><br><span class="line"> return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>同理：查找最好为第一个，最差为查找n次，平均比较次数为**(1+n)&#x2F;2**</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="从顺序表中删除具有最小值的元素（假设唯一），并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示错误信息并退出运行。"><a href="#从顺序表中删除具有最小值的元素（假设唯一），并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示错误信息并退出运行。" class="headerlink" title="从顺序表中删除具有最小值的元素（假设唯一），并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示错误信息并退出运行。"></a>从顺序表中删除具有最小值的元素（假设唯一），并由函数返回删除元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示错误信息并退出运行。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">bool Del_Min(SqList &amp;L,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    if(L.length==0) return false;</span><br><span class="line">    int min=0;</span><br><span class="line">    for(int i=1;i&lt;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.data[i]&lt;L.data[min])</span><br><span class="line">        &#123;</span><br><span class="line">            min=i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    e=L.data[min];</span><br><span class="line"></span><br><span class="line">    L.data[min]=L.data[L.length-1];</span><br><span class="line">    L.length--;</span><br><span class="line">    return true;                                                                                                                                                                                                                                                                       </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```         </span><br><span class="line">### 设计一个高效的算法，将顺序表L中的元素逆置，要求空间复杂度为O(1)</span><br></pre></td></tr></table></figure>
<p>void Rverse(SqList &amp;L)<br>{<br>    ElemType e;<br>    for(int i&#x3D;0;i&lt;&#x3D;L.length&#x2F;2;i++)<br>    {<br>        e&#x3D;L.data[i];<br>        L.data[i]&#x3D;L.data[L.length-1-i];<br>        L.data[L.length-1-i]&#x3D;e;<br>    }<br>}</p>
<pre><code>### 对长度为n的顺序表L，编写一个时间复杂度为O（n），空间复杂度为O（1）的算法，该算法删除顺序表中所有值为x的数据元素。
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%AA%E8%AE%BA/" data-id="cm6ezk1uh00001ky03mqvfh8s" data-title="数据结构的绪论" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/02/04/%E9%93%BE%E8%A1%A8/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          链表
        
      </div>
    </a>
  
  
    <a href="/2025/01/25/first-try-blog/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">first_try_blog</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/03/">March 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/01/">January 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/03/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">微信小程序</a>
          </li>
        
          <li>
            <a href="/2025/02/04/%E9%93%BE%E8%A1%A8/">链表</a>
          </li>
        
          <li>
            <a href="/2025/01/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E7%BB%AA%E8%AE%BA/">数据结构的绪论</a>
          </li>
        
          <li>
            <a href="/2025/01/25/first-try-blog/">first_try_blog</a>
          </li>
        
          <li>
            <a href="/2025/01/25/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>